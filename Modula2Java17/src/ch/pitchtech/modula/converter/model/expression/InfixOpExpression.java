package ch.pitchtech.modula.converter.model.expression;


import java.util.Set;

import ch.pitchtech.modula.converter.compiler.CompilationException;
import ch.pitchtech.modula.converter.compiler.CompilerException;
import ch.pitchtech.modula.converter.generator.ResultContext;
import ch.pitchtech.modula.converter.generator.expression.InfixOpExpressionGenerator;
import ch.pitchtech.modula.converter.model.builtin.BuiltInType;
import ch.pitchtech.modula.converter.model.scope.IScope;
import ch.pitchtech.modula.converter.model.scope.TypeResolver;
import ch.pitchtech.modula.converter.model.source.NodeAttachType;
import ch.pitchtech.modula.converter.model.source.SourceElement;
import ch.pitchtech.modula.converter.model.source.SourceLocation;
import ch.pitchtech.modula.converter.model.type.EnumSetType;
import ch.pitchtech.modula.converter.model.type.EnumerationType;
import ch.pitchtech.modula.converter.model.type.IType;
import ch.pitchtech.modula.converter.model.type.LiteralType;
import ch.pitchtech.modula.converter.model.type.RangeSetType;


public class InfixOpExpression extends SourceElement implements IExpression {
    
    private final static Set<String> RELATION_OPERATORS = Set.of("=", "#", "<>", "<", "<=", ">", ">=", "IN");
    private final static Set<String> BOOLEAN_OPERATORS = Set.of("OR", "AND", "&");
    private final static Set<String> MATH_OPERATORS = Set.of("+", "-", "*", "/", "DIV", "MOD");
    private final static Set<String> SET_OPERATORS = Set.of("+", "-", "*", "/");
    
    private final IExpression left;
    private final String operator;
    private final IExpression right;
    private IType forceType;
    
    
    public InfixOpExpression(SourceLocation sLoc, IExpression left, String operator, IExpression right) {
        super(sLoc);
        this.left = left;
        this.operator = operator;
        this.right = right;
        attach(left, NodeAttachType.READ_ACCESS);
        attach(right, NodeAttachType.READ_ACCESS);
    }
    
    public IExpression getLeft() {
        return left;
    }

    public String getOperator() {
        return operator;
    }
    
    public IExpression getRight() {
        return right;
    }

    @Override
    public boolean isConstant(IScope scope) {
        return left.isConstant(scope) && right.isConstant(scope);
    }
    
    public IType getForceType() {
        return forceType;
    }
    
    /**
     * Used by expressions generated by INC or DEC. In such a case we force the type of the first operand.
     * <p>
     * This is necessary for instance when using INC or DEC on a CHAR
     */
    public void setForceType(IType forceType) {
        this.forceType = forceType;
    }

    @Override
    public boolean isComplex(ResultContext context) {
        if (operator.equals("IN"))
            return false; // Uses a method
        IType leftType = context.resolveType(getLeft());
        IType rightType = context.resolveType(getRight());
        if (leftType instanceof EnumSetType && rightType instanceof EnumSetType) {
            return false; // Uses methods
        } else if (leftType instanceof RangeSetType && rightType instanceof RangeSetType) {
            return false; // Uses methods
        } else if (InfixOpExpressionGenerator.requiresMethod(leftType, rightType, getOperator())) {
            return false; // Uses methods
        } else if (InfixOpExpressionGenerator.requiresEuclidean(context, left, right, leftType, rightType, getOperator())) {
            return false; // Uses methods
        }
        
        // General case, assume a Java operator is used
        return true;
    }

    @Override
    public IType getType(IScope scope, IType forType) {
        if (forceType != null)
            return forceType;
        if (RELATION_OPERATORS.contains(operator) || BOOLEAN_OPERATORS.contains(operator))
            return new LiteralType(BuiltInType.BOOLEAN);
        if (MATH_OPERATORS.contains(operator)) {
            IType t1 = TypeResolver.resolveType(scope, left.getType(scope));
            IType t2 = TypeResolver.resolveType(scope, right.getType(scope));
            if (t1 instanceof LiteralType l1 && t2 instanceof LiteralType l2) {
                if (l1.isBuiltIn() && l2.isBuiltIn()) {
                    BuiltInType b1 = BuiltInType.valueOf(l1.getName());
                    BuiltInType b2 = BuiltInType.valueOf(l2.getName());
                    if (b1.isNumeric() && b2.isNumeric())
                        return new LiteralType(BuiltInType.javaInfixNumeric(scope, b1, b2));
                    else if (b1.equals(b2))
                        return l1;
                    else
                        throw new CompilationException(this, "Incompatible types {0} and {1}", l1, l2);
                }
            }
        }
        if (SET_OPERATORS.contains(operator)) {
            IType t1 = TypeResolver.resolveType(scope, left.getType(scope));
            IType t2 = TypeResolver.resolveType(scope, right.getType(scope));
            if (t1 instanceof EnumSetType enumSetType1 && t2 instanceof EnumSetType enumSetType2) {
                IType enumType1x = TypeResolver.resolveType(scope, enumSetType1.getEnumerationType());
                IType enumType2x = TypeResolver.resolveType(scope, enumSetType2.getEnumerationType());
                if (enumType1x instanceof EnumerationType enumType1 && enumType2x instanceof EnumerationType enumType2) {
                    if (enumType1.getName().equals(enumType2.getName())) {
                        return enumSetType1;
                    }
                }
            }
            if (t1 instanceof RangeSetType rangeSetType1 && t2 instanceof RangeSetType) {
                // Assume the bounds are the same...
                return rangeSetType1;
            }
        }
        throw new CompilerException(this, "Cannot infer expression type for {0}", this);
    }

    @Override
    public String toString() {
        return "InfixOpExpression [left=" + left + ", operator=\"" + operator + "\", right=" + right + "]";
    }

}
