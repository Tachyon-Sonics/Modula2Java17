This blog-like articles summarizes my experience using claude code in a ~5 hours session.

5 hours might seem short, and it is. However, I prepared the problem I wanted claude to solve; namely 3 problems that I had already solved on my own in a different branch, and 3 other questions on things I'm not particularly familiar with, and hence where claude could potentially help me the most.

First, I chose as a starting point an existing project I was working on: a Modula-2 to Java translator. This is a command-line application that translates one or more files written in the Modula-2 programming language into equivalent code in the Java language. The two programming languages are different enough so that it cannot be done using simple (or even elaborate) search/replace rules, but requires an architecture similar (although simpler) to that of a compiler: parsing, abstraction with a model of the source code, analyses and transformations, and then code generation.

The project is a project that is already working, but still has bugs and limitation. The project is medium small in size, but probably above average in complexity. An interesting point is that it involves both main stream, and less known technologies. Java, gradle, antlr and junit are quite mainstream, whereas the Modula-2 programming language is rather little known. Moreover, a compiler / translator is not the most common type of application out there, although it's not completely marginal either.

Now let's start with the different tasks asked to claude code.

The three first questions correspond to tasks I already did myself on a different branch, and took me about 2 hours.

Note that it definitely helps understanding this blog if you known about the Modula-2 programming language (or at least a similar one like Pascal or Oberon), however I'll try to explain the basics that need to be known.

First question, difficulty: moderate - simple

The first task was to fix a bug. In Modula-2 you can declare a variable of a bit set type (similar to Java's BitSet, but with fixed bounds) by first declaring the type and then the variable as follows:

    TYPE MySet = SET OF [0..15];
    VAR myVar : MySet;
    
However, the language also allows you to specify the type "inline" as follows:

    VAR myVar: SET OF [0..15];
    
In the existing code, the first variant is working, but the second one is not. The first variant generates a Java constant named `MySet_r` of type `Runtime.Range(0, 15)` (`Runtime.Range` is a type defined in the "runtime" Java project, used both by the compiler and by the generated Java code), and then declares the `myVar` variable a a new `Runtime.RangeSet(MySet_r)`.

The second variant only declares the `myVar` variable a new `Runtime.RangeSet(_myVar_r)`, resulting in a compilation error because `_myVar_r` is not defined. Note that in my own solution I fixed it so that it generates a `Runtime.RangeSet(0..15)`, but I did not tell claude anything about how to solve the problem. However I pointed him an existing junit test that tests exactly the situation, and hence currently fails.

Claude properly discovered the main structure of the application, namely the different projects (the compiler, the runtime and the test project).

Interestingly, he founds a solution different that my own, by adding the `RangeSetType` class (the class that models Modula-2 bit sets) to the list in a method `requiresExplicitDeclaration`. This method already includes Modula-2 procedure and record type; it means that if one of these type is used "inline", the compiler must still declare the type with a synthetic name.

The solution is definitely correct. However the code required, at some place, to remove a duplicate "_r" suffix from a type name. This code looks a bit hacky, but clause added a quite clear comment to explain it.

Claude could also sucessfully make the test pass, by adapting the expected generated code. However it struggled a little here.

The reason is that I used a rather odd design. In general, if you want to test any code that generates something, the test will hold the expected result in the form of a constant or a resource, and compare it with the actual one. However, in this project, the expected result is a Java class that is part of the test project (Modula2Java17-Test) and that is hence included in the compilation. This has a few advantages, namely I can immediately check if the generated code is valid Java code, and I can also run it (manually or as a part of the junit test) to further check that it produces the correct output.

On the other hand, it means that the test project won't compile if it includes a Java class generated by the compiler that does not compile.

However, I'm using the Eclipse IDE, and one of its unique feature is that it can launch code even if some classes do not compile. The code will just throw an exception at run-time if code that failed to compile is ever encountered. As such, having a few classes that temporarily do not compile was not a problem in my day to day work with Eclipse. But gradle does not have such a feature, and I only told claude that it was a gradle project.

Claude worked around the problem by temporarily commenting some lines of code in the generated code, and then uncommenting or replacing them, but it needed multiple steps that sometimes looked like "trial or error", sometimes like "iterative", to find it out.


Note that I finally kept my own version of the code, because there is no reason to explicitly declare a bit set type (unlike for record and procedure types) and hence my inline version is simpler. Note that I could have asked claude to change to an inline version, and I'm pretty sure it could have done it (based on my experience with the other tasks).

Until now this was almost a 100% success. I can also add that the code generated by claude so far matched my formatting / coding style, however it's difficult to say if it will really match any style, as mine is close to the Java's standard recommanded by Oracle. I noticed later a few discrepancies, namely claude refered to class using the full package name instead of adding an import in some situations, something I never do (unless two classes from different packages have the same name are are ambiguous).


Second question: difficulty medium

In addition to the possibility of declaring bit sets with arbitrary bounds, the Modula-2 language has a built-in type named `BITSET`. This built-in type is the same as `SET OF [0..15]` in a 16-bit data model, and `SET OF [0..31]` in a 32-bit data model (observer that both bounds are inclusive).

The `BITSET` type was declared in the compiler's code as one of the built-in types, but was not handled at all and is hence not working. I asked claude to implement it. I only pointed the class holding the data model as a hint, but gave no other instruction.

Claude correctly indentified the key classes, namely `BuiltInType` for the list of built-in Modula-2 types, and `TypeResolver` in which user-defined types are "resolved" either to builtin types or to Modula-2 constructs such as records, arrays, etc.

It took the same approach as me. After the type is resolved, it checked it against the `BITSET` built-in type, and replaced it with a `RangeSetType`, which is the type that models all `SET OF [<low>..<high>]` bit set types. It also properly used the `getNbBits()`method of the data model class, substracting 1 to get the upper bound. However it detected the `BITSET` by name (comparing the type name with the `"BITSET"` string). After instructing it to use the `isBuiltInType` method it corrected it to `isBuiltInType(BuiltInType.BITSET)` as expected.

However, it also made a mistake.

It then added a test, ran it, and discovered that the test failed. The `BITSET` type was just not resolved at all.

To understand the mistake, the code in `TypeResolver` before the change looked like (pseudo-code):

    public IType resolveType(IType type) {
	    if (type is not built-in)
	        return resolveTypeImpl(...);
	    
	    <a few assertions for built-in types>
    
    	return type; // built-in type, no resolution needed
    }
    
This function has two exit points, and claude added the conversion of `BITSET` to a `RangeSetType` after the assertions, before the second exit point. In fact the "conversion" code has to be added in *both* exit points (you can then refactor the code a little so that the conversion is not duplicated, for instance by setting the `type` variable to the resolved type instead of returning immediately in the `if`).

Claude then modified the code again, this time adding similar code in the `resolveTypeImpl`. While the test passed after this change, there was definitely a red flag.

The `BITSET` type was again tested by name instead of using the `isBuiltInType`.

When instructed again to use `isBuiltInType`, it made the change, re-run the test, noticed that the test failed, reverted the change, and then explained me the reason: in `resolvedTypeImpl` unlike in `resolveType`, the type may not be resolved yet, and hence may not be known yet to be a built-in type. This is why it is necessary, accoring to claude, to test it by name.

On one hand, the code is correct, and the test pass successfully. On the other hand, this kind of string comparison was clearly a red flag to me. At the time, I just continued with the next task because the code was working and I did not feel it was necessary to further improve it yet. After all I already solved the problem exactly like I wanted on another branch.

However, the next day when I reviewed it again, I notice that the code generated by claude did not work if the Modula-2 declares a user type that is an alias to the `BITSET` type as follows: `TYPE MyBitSetAlias = BITSET`. So the code generated by claude was not just a red flag or bad style, but was incorrect.

Going back to my session with claude, there was another red flag. It was again caused by a rather weird design choice in my existing code.

The Modula-2 to Java compiler sometimes produces Java code that has warnings. Examples are warnings about an unused import, or an unused method (typically getters and setters, that the compiler only use when Modula-2 record' fields are passed as arguments to a function by reference). Also remind that the code generated by the compiler as part of the automated tests is placed in the test project, as Java classes that are included in the compilation.

However I have a zero warning policy in almost all of my projects (both personal and professional). Hence I took the following choices (that are likely quite unusual):

- In the classes corresponding to the expected generated code, I explicitely fix the warnings (either by removing an unused import, or adding a `@SuppressWarning` annotation).
- In the testing code, the method that compares the generated code with the expected one (in a utility class named `CompileHelper`) has a varargs argument that is a list of lines to ignore. These lines to ignore can be either removed (unused import) or added (SuppressWarning) lines.

I could definitely have instructed claude about this desing choice, but I did not. There was no particular reason for that appart from the fact I wanted to somehow simulate a situation in which I was not familiar with the code at all (although I definitly am as I wrote it entirely myself).

First claude needed multiple steps to capture the code generated by the compiler:

- It properly deduced that the code was generated in `/tmp`, but failed to find it.
- It then correctly noticed that the testing code deletes the generated code at the end of the tests.
- It made a first try to invoke the compiler directly, but failed (don't remember the exact reasons, but the command-line options are definitely not straightforward)
- It then made a small temporary Java class to invoke the compiler programmatically and dump the generated code, but failed to launch it with the `java` command (it failed to properly add the runtime project as a dependency)
- It finally added a temporary gradle class to run the temporary class, and could finally capture the compiler's output by executing the task using gradle. Interestingly the output is embedded in an xml file generated by gradle, and claude issued a complex `grep` command to retrieve it.
- It properly cleaned up the temporary Java class and gradle task at the end

This approach is interesting. On one hand, it looks like trial and error. On the other hand, it can also be viewed as an iterative approach to find the simplest solution. After all, if you cannot quickly succeed in invoking the compiler directly, maybe this is not the simpler approach and you better try another one instead.

Note that for the next task I explicitely instructed it to create a dummy Java file for the expected result, because in that case the `CompileHelper` class will print the generated result if it does not match.

Then it copied the generated Java code to the target class. This class has a warning with an unused import. Claude did not remove it, but also include the line to the lines to ignore. Probably because most existing tests include this line.

- Noticing that the test fails (because the line to ignore *is* present), it then removed it from *both* the expected Java file and from the list of lines to ignore.
- The test abviously failed again, and claude reported (somehow correctly) "it's weird now I have the exact opposite problem".
- It then tried different cleanup (recompiling the code from scratch) without success
- Finally it removed the import, this time *only* from the list of line to ignore and could get the test to pass.

However it gave me a small summary that was definitely incorrect: basically it told that the compiler sometimes generates the import and sometimes not. It explained that fortunately the list of lines to ignore in the helper method handles both added and removed lines, and hence can be used to handle this situation.

It did not mention "Schr√∂dinger", but this is how I understand it. Namely it strongly suggested that parts of the code behave randomly, and sometimes generates something, and sometimes something else. While such things definitely exist (especially with multi-threaded code), this was not the case of the compiler. If I did not knew the project and did not understand the mistake in claude's reasoning, I could definitely be inclined to belive there was a deeper problem in the compiler, because a compiler that does not behave in a deterministic way would be a huge red flag.

On the other hand, remind that I did not instruct it of how these "lines to ignore" are used and why.


Third problem - simple

This question is again related to Modula-2 bit set types. Modula-2 defines the basic operators on bit set types as `+` for union (or), `-` for difference (and not), `*` for intersection (and), and `/` for symmetric difference (xor).

The generated Java code for Modula-2 `set3:= set1 + set2;` was at that time:

    set3.copyFrom(Runtime.RangeSet.plus(set1, set2));

It first explained to claude that the operators `+`, `-`, `*` and `/` are mapped to the methods `plus`, `minus`, `mul` and `div` of the `Runtime.RangeSet` class. I then explained that the generated code is suboptimal because it creates a copy using `copyFrom` although the methods from `Runtime.RangeSet` already create a copy. I asked him to change the compiler to emit more optimal code (without the `copyFrom`) and to create a unit test for it.

I also told it to create a dummy file for the expected generated Java code so that the helper class used in the test will print the actual generated code if it does not match when asserting the result. The idea was to prevent the multiple steps required to extract the compiler's output in a previous task.

- claude correctly noticed that the method from `Runtime.RangeSet` all make a copy, using `clone()`.
- it also correctly noticed that code already existed to optimize out the copy for the `EnumSetType` and that similar code can be used for `RangeSetType`.
    - `EnumSetType` is used in the compiler when you define an enumeration in Modula-2 (mapped to a Java `enum` by the compiler), and then define a set over that enumeration. This is similar to Java's `EnumSet` class, and the generated Java code indeed use Java's `EnumSet` in that case
    - `RangeSetType` is used in the compiler when you define a set over an integer range. It is mapped in the generated Java code to the `RangeSet` class from the runtime, that uses `java.util.BitSet` behind the scene.
- Although Modula-2 is not a mainstream programming language, claude was able to create a small Modula-2 module correctly (a "module" is the basic unit in Modula-2, like a class in Java), to test the optimisation. It was properly added with other existing Modula-2 test modules in the test projects.
    - On one hand this is quite impressive. The module includes usage of the four operators on relevant values with the expected result in comments (properly formatted as Modula-2 comments, that use the `(*` syntax `*)`)
    - On the other hand, it did not try to add assertions or outputs to stdout, which would be required if one wants to also assert that the operators indeed produce the correct results. Indeed, in many of the existing tests, values are output to stdout, and the test executes the generated Java class and asserts the output against the expected one. This allows me to not only test the output of the compiler itself, but also the runtime behavior of the generated code.
- interestingly, I told him to first create a dummy Java class for the expected code, so that the test automatically dumps the actual code if it does not match (to avoid the previous struggle where claude tries to extract the compiler's output). But claude did not just make a dummy (empty) Java class, but was able to create the exact Java class the compiler would generate correctly!
    - This is interesting as it suggests that claude could potentielly be used to directly convert Modula-2 code to Java. Of course this is another, and big question, and it is difficult to say how efficient it would be in the general case based on this rather simple case only (40 lines of Modula-2 code). In particular, Modula-2 allows arguments to be passed either by value or by reference, and handling this feature correctly is far from trivial and is a big part of the compiler. And it's only one of the difficulties in writing this compiler.
    
This third task was a success.


At that time I had the feeling I was very productive. After all, claude did most of the stuff and I just had to review the code, and point out errors in order to fix them...

However, looking at my clock, I got another story... about 1h40 passed, much closer than I thought to the 2 hours I required when I did the same three tasks by hand. And its not counting red flags such as a mistake in `BITSET` handling that I left unfixed.

On the other hand, this is my first experience with claude code, and there are probably many ways of improving the productivity.


Fourth task - simple

Basically the test project `Modula2Java17-Test` was configured in gradle as a regular project, and not as a test project. I'm not familiar with gradle, and I asked claude if there was a way, according to existing best practices, to properly configure it as a test project.

It came with two options:

- One involved also changing the `src` folder into `src/test/java` and updating the gradle configuration to add a `test` goal.
- The second one was to preserve the existing structure and to just add the `test` gloal.

I chose the second one, and it properly added the `test` gloal. I then asked him to split the `test` gloal into two, one than only executes the `FastRootSuite` and the other one (`testFull`) that executes the `RootSuite`, because the later requires other third-party Modula-2 projects to be present. This was also done correctly.


Fifth task - simple

I choose this task and the next one because it involves the antlr library and the antlr grammar file, and I'm not particularly familiar with those. 

I explained that the compiler properly handles Modula-2 comments (that use the `(*` and `*)` syntax), but does not properly handle nested comments, which are allowed in Modula-2.

TODO: struggle in regenerating the grammar (attempt to download antlr); when instructed, new gradle task to use the exisiting Java utility class


Task 6 - complex

This task is the one that revealed most of claude's limitations. It is also the most complex one I submitted to claude, but yet it still does not match the complexity of some existing parts of the compiler.

I explained that while the compiler handles Modula-2 comments, it just ignores them. I asked him to improve the compiler so that Modula-2 comments are preserved in the generated Java code, and converted to Java's block format with `/*` and `*/`. I also pointed that most classes modelling statments extend the `SourceFile` class, and that could be of help because this class provides the line and column number of the corresponding statement in the original Modula-2 code. Interestingly, the actual class is `SourceElement` and not `SourceFile` (that is completely unrelated), but claude understood that I actually meant `SourceElement`. Note that I did *not* make the mistake on purpose, which made it quite an interesting experience.

TODO:
- first extract comments and put them all at the beginning of the Java file + test
- also fixed another test in which the Modula-2 code had comment, by adding them in the expected generated Java class.
- ask him to preserve location at the statement level.
- a few unused method, one is irrelevant (detect if a comment should be a javadoc - but based on javadoc content, not on anything Modula-2 related)
- Hard coded "2 lines" before, then changed to 10, then an hallucination and wanted to change to 5
- First did not handle nested comment properly. Gave instructions: if nested comments are encountered, only the outer comment muste be converted to `/*` and `*/`, but the inner ones must keep the `(*` and `*)` syntax
- additional steps to preserve multi-line comments, and to preserve indentation. Wrote a `normalizeIndentation` method, noticing that the classes used to generate the Java code already indent the lines.
- Told that a comment inside of an expression must also be preserved, but is allowed to be moved before the enclosing statement
- Found a bug if two comments appear on the same line (occured in the test case produced by claude, but the test passed because the expected result was also wrong). Only the first comment was preserved. Fixed by claude.
- Forgot comments in definition modules
