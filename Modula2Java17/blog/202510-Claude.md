This blog-like articles summarizes my experience using claude code in a ~5 hours session.

5 hours might seem short, and it is. However, I prepared the problem I wanted claude to solve; namely 3 problems that I had already solved on my own in a different branch, and 3 other questions on things I'm not particularly familiar with, and hence where claude could potentially help me the most.

First, I chose as a starting point an existing project I was working on: a Modula-2 to Java translator. This is a command-line application that translates one or more files written in the Modula-2 programming language into equivalent code in the Java language. The two programming languages are different enough so that it cannot be done using simple (or even elaborate) search/replace rules, but requires an architecture similar (although simpler) to that of a compiler: parsing, abstraction with a model of the source code, analyses and transformations, and then code generation.

The project is a project that is already working, but still has bugs and limitation. The project is medium small in size, but probably above average in complexity. An interesting point is that it involves both main stream, and less known technologies. Java, gradle, antlr and junit are quite mainstream, whereas the Modula-2 programming language is rather little known. Moreover, a compiler / translator is not the most common type of application out there, although it's not completely marginal either.

Now let's start with the different tasks asked to claude code.

The three first questions correspond to tasks I already did myself on a different branch, and took me about 2 hours.

Note that it definitely helps understanding this blog if you known about the Modula-2 programming language (or at least a similar one like Pascal or Oberon), however I'll try to explain the basics that need to be known.

First question, difficulty: moderate - simple

The first task was to fix a bug. In Modula-2 you can declare a variable of a bit set type (similar to Java's BitSet, but with fixed bounds) by first declaring the type and then the variable as follows:

    TYPE MySet = SET OF [0..15];
    VAR myVar : MySet;
    
However, the language also allows you to specify the type "inline" as follows:

    VAR myVar: SET OF [0..15];
    
In the existing code, the first variant is working, but the second one is not. The first variant generates a Java constant named `MySet_r` of type `Runtime.Range(0, 15)` (`Runtime.Range` is a type defined in the "runtime" Java project, used both by the compiler and by the generated Java code), and then declares the `myVar` variable a a new `Runtime.RangeSet(MySet_r)`.

The second variant only declares the `myVar` variable a new `Runtime.RangeSet(_myVar_r)`, resulting in a compilation error because `_myVar_r` is not defined. Note that in my own solution I fixed it so that it generates a `Runtime.RangeSet(0..15)`, but I did not tell claude anything about how to solve the problem. However I pointed him an existing junit test that tests exactly the situation, and hence currently fails.

Claude properly discovered the main structure of the application, namely the different projects (the compiler, the runtime and the test project).

Interestingly, he founds a solution different that my own, by adding the `RangeSetType` class (the class that models Modula-2 bit sets) to the list in a method `requiresExplicitDeclaration`. This method already includes Modula-2 procedure and record type; it means that if one of these type is used "inline", the compiler must still declare the type with a synthetic name.

The solution is definitely correct. However the code required, at some place, to remove a duplicate "_r" suffix from a type name. This code looks a bit hacky, but clause added a quite clear comment to explain it.

Claude could also sucessfully make the test pass, by adapting the expected generated code. However it struggled a little here.

The reason is that I used a rather odd design. In general, if you want to test any code that generates something, the test will hold the expected result in the form of a constant or a resource, and compare it with the actual one. However, in this project, the expected result is a Java class that is part of the test project (Modula2Java17-Test) and that is hence included in the compilation. This has a few advantages, namely I can immediately check if the generated code is valid Java code, and I can also run it (manually or as a part of the junit test) to further check that it produces the correct output.

On the other hand, it means that the test project won't compile if it includes a Java class generated by the compiler that does not compile.

Claude worked around the problem by temporarily commenting some lines of code in the generated code, and then uncommenting or replacing them, but it needed multiple steps that sometimes looked like "trial or error", sometimes like "iterative", to find it out.

Note that I finally kept my own version of the code, because there is no reason to explicitly declare a bit set type (unlike for record and procedure types) and hence my inline version is simpler. Note that I could have asked claude to change to an inline version, and I'm pretty sure it could have done it (based on my experience with the other tasks).

Until now this was almost a 100% success. I can also add that the code generated by claude matched my formatting / coding style, however it's difficult to say if it will really match any style, as mine is close to the Java's standard recommanded by Oracle.


Second question: difficulty medium

In addition to the possibility of declaring bit sets with arbitrary bounds, the Modula-2 language has a built-in type named `BITSET`. This built-in type is the same as `SET OF [0..15]` in a 16-bit data model, and `SET OF [0..31]` in a 32-bit data model (observer that both bounds are inclusive).

The `BITSET` type was declared in the compiler's code as one of the built-in types, but was not handled at all and is hence not working. I asked claude to implement it. I only pointed the class holding the data model as a hint, but gave no other instruction.

Claude correctly indentified the key classes, namely `BuiltInType` for the list of built-in Modula-2 types, and `TypeResolver` in which user-defined types are "resolved" either to builtin types or to Modula-2 constructs such as records, arrays, etc.

It took the same approach as me. After the type is resolved, it checked it against the `BITSET` built-in type, and replaced it with a `RangeSetType`, which is the type that models all `SET OF [<low>..<high>]` bit set types. It also properly used the `getNbBits()`method of the data model class, substracting 1 to get the upper bound. However it detected the `BITSET` by name (comparing the type name with the `"BITSET"` string). After instructing it to use the `isBuiltInType` method it corrected it to `isBuiltInType(BuiltInType.BITSET)` as expected.

However, it also made a mistake.

It then added a test, ran it, and discovered that the test failed. The `BITSET` type was just not resolved at all.

To understand the mistake, the code in `TypeResolver` before the change looked like (pseudo-code):

    public IType resolveType(IType type) {
	    if (type is not built.in)
	        return resolveTypeImpl(...);
	    
	    <a few assertions for built-in types>
    
    	return type; // built.in type, no resolution needed
    }
    
This function has two exit points, and claude added the conversion of `BITSET` to a `RangeSetType` after the assertions, before the second exit point. In fact the "conversion" code has to be added in both exit points (you can then refactor the code a little so that the conversion is not duplicated, for instance by setting the `type` variable to the resolved type instead of returning immediately in the `if`).

Claude then modified the code again, this time in the `resolveTypeImpl`. While the test passed after this change, there was definitely a red flag.

The `BITSET` type was again tested by name instead of using the `isBuiltInType`.

When instructed again to use `isBuiltInType`, it made the change, re-run the test, noticed that the test failed, reverted the change, and then explained me the reason: in `resolvedTypeImpl` unlike in `resolveType`, the type may not be resolved yet, and hence may not be known yet to be a built-in type. This is why it is necessary to test it by name.

On one hand, the code is correct, and the test pass successfully. On the other hand, this kind of string comparison was clearly a red flag to me. At the time, I just continued with the next task because the code was working and I did not feel it was necessary to improve it yet.

However, the next day when I reviewed it again, I notice that the code generated by claude did not work if the Modula-2 declares a user type that is an alias to the `BITSET` type as follows: `TYPE MyBitSetAlias = BITSET`. I dit not ask for a fix as I already merged by own version on the main branch.

However, going back to my session with claude, there was another red flag. It was again caused by a rather weird design choice in my existing code.

The compiler sometimes produces code that has warnings. Examples are warnings about an unused import, or an unused method (typically getters and setters, that the compiler only use when Modula-2 record' fields are passed as arguments to a function by reference). Also remind that the code generated by the compiler as part of the automated tests is placed in the test project, as Java classes that are included in the compilation.

However I have a zero warning policy in almost all of my projects (both personal and professional). Hence I took the following choices:

- In the generated code, I explicitely fix the warnings (either by removing an unused import, or adding a `@SuppressWarning` annotation).
- In the testing code, the method that compares the generated code with the expected one (in a utility class named `CompileHelper`) has a varargs argument of lines to ignore. These lines to ignore can be either removed (unused import) or added (SuppressWarning) lines.

I could definitely have instructed claude about this desing choice, but I did not. There was no particular reason for that appart from the fact I wanted to somehow simulate a situation in which I was not familiar with the code at all (although I definitly am as I wrote it entirely myself).

First claude needed multiple steps to capture the code generated by the compiler:

- It properly deduced that the code was generated in `/tmp`, but failed to find it.
- It then correctly notices that the code deletes the generated code at the end of the tests.
- It made a first try to invoke the compiler directly, but failed (don't remember the exact reasons, but the command-line options are definitely not straightforward)
- It then made a small temporary Java class to invoke the compiler programmatically and dump the generated code, but failed to launch it with the `java` command
- It finally also added a temporary gradle class to run the temporary class, and could finally capture the compiler's output. Interestingly the output is embedded in an xml file generated by gradle, and claude issued a complex grep command to retrieve it.

This approach is interesting. On one hand, it looks like trial and error. On the other hand, it look like an iterative approach to find the simplest solution. After all, if you cannot quickly succeed in invoking the compiler directly, maybe this is not the simpler approach and you better try another one instead...

Note that for the next task I explicitely instructed it to create a dummy Java file for the expected result, because in that case the `CompileHelper` class will print the generated result if it does not match.

Then it copied the generated Java code to the target class. This class has a warning with an unused import. Claude did not remove it, but also include the line to the lines to ignore. Probably because most existing tests include this line.

- Noticing that the test fails (because the line to ignore *is* present), it removed it from *both* the expected Java file and from the list of lines to ignore.
- The test failed again, and claude reported (somehow correctly) "it's weird now I have the exact opposite problem".
- It then tried different cleanup (recompiling the code from scratch) without success
- Finally it removed the import from the list of line to ignore and could get the test to pass.

However it gave me a small summary that was definitely incorrect: basically it told that the compiler sometimes generated the import and sometimee not. It explained that fortunately the list of lines to ignore handles both added and removed lines, and hence can be used to handle this situation.

It did not mention "Schr√∂dinger", but this is how I understand it. Namely part of the code that behaves randomly, and sometimes generates something, and sometimes something else. While this definitely exist (especially with multi-threaded code), this was not the case of the compiler. If I did not knew the project and did not understand the error in claude's reasoning, I could definitely be inclined to belive there was a deeper problem in the compiler, because a compiler that does not behave in a deterministic way would be a huge red flag.

On the other hand, remind that I did not instruct it of how these lines to ignore are used and why.


Third problem - simple

This question is again related to Modula-2 bit set types. Modula-2 defines the basic operators on bit set types as `+` for union (or), `-` for difference (and not), `*` for intersection (and), and `/` for symmetric difference (xor).

The generated Java code for Modula-2 `set3:= set1 + set2;` is:

    set3.copyFrom(Runtime.RangeSet.plus(set1, set2));

It first explained to claude that the operators `+`, `-`, `*` and `/` are mapped to the methods `plus`, `minus`, `mul` and `div` of the `Runtime.RangeSet` class. I then explained